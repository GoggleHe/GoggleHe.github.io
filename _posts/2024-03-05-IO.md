---
layout: post
title: IO模型
categories: [网络编程]
description: IO
keywords: IO
---

## IO模型

### 1. 常见IO模型

- 同步阻塞I/O
- 同步非阻塞I/O
- I/O多路复用
- 信号驱动I/O
- 异步I/O

### 2. 多路复用的三个函数

#### 2.1 select

##### 2.1.1 函数定义

```c++
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```

参数

- readfds：内核检测该集合中的文件描述符是否可读。如果想让内核检测某个IO是否可读，需要手动把文件描述符加入到该集合。
- writefds：内核检测该集合中的文件描述符是否可写。同readfds，需要手动把文件描述符加入到该集合。
- exceptfds：内核检测该集合中的文件描述符是否异常。同readfds，需要手动把文件描述符加入到该集合。
- nfds：以上三个集合中最大的文件描述符数值+1。例如集合是{0,1,5,10}，那么maxfd就是11。
- timeout：用户线程调用select的超时时长。设置为null，表示如果线程会一直阻塞直到I/O事件发生；设置为非0的值，表示阻塞固定一段时间后返回；设置为0，表示检测完毕立即返回。

 返回值

- 等于-1：表示调用失败
- 大于0：成功，返回集合中就绪的IO总个数
- 等于0：表示没有就绪的IO

 fd_set的操作函数

```C++
// 将文件描述符fd从set集合中删除
void FD_CLR(int fd, fd_set *set);

// 判断文件描述符是否在set集合中
void FD_ISSET(int fd, fd_set *set);

// 将文件描述符fd添加到fd集合中
void FD_SET(int fd, fd_set *set);

// 将set集合中，所有文件描述符对应的标志位设置为0
void FD_ZERO(fd_set *set);
```

- select函数底层使用位图存储f存储文件描述符，以上函数均为对位图的操作

##### 2.1.2 select执行逻辑

1. 当用户线程调用select的时候，会将fd_set拷贝到内核中。(这里发生了一次复制)
2. 然后内核会遍历文件描述符检查是否数据是否就绪。
3. 若发现文件描述符数据就绪，返回就绪的文件描述符数量。

##### 2.1.3 select的缺点

1. select可以监听的文件描述符数量有上限。32位机默认上限为1024，64位机默认上限为2048。
2. 每次调用select都需要将被监控的fds集合拷贝到内核中，高并发场景下这样的拷贝对于资源的消耗是很大的。
3. select返回的时候，用户线程并不知道具体是哪些文件描述符就绪了，需要遍历被监听的文件描述符来检查。那么被监听的文件描述符越多，遍历检查的耗时越长。

##### 2.1.4 文件描述符

1. 一个进程最大的文件描述符数量
   1. 相关命令
      - `ulimit -n`命令查看当前一个进程最大文件描述符数量
      - `ulimit -n 2048`修改当前会话的最大文件描述符数量
      - `cat /proc/sys/fs/nr_open`获取最大文件描述符数量
      - `/etc/security/limits.conf`永久修改最大文件描述符数量
   2. limits.conf文件配置详解
      1. 格式：`<domain>        <type>  <item>  <value>`
      2. 详解
         - domain: 代表限制的对象，对哪些用户生效。其可以是一个用户名，也可以是一个用户组的名字，可以使用通配符*和%。
         - type: 仅仅有两种， soft和hard。 soft的限制的值不能超过hard限制的值。
         - item： 代表可以限制的内容, 可以有下面的一些选项可以设置
           - core - 显示coredump文件的大小 (单位KB)
           - data - 最大数据大小 (单位KB)
           - fsize - 最大文件大小 (单位KB)
           - memlock - 最大锁定内存地址空间 (单位KB)
           - nofile - 最大可以打开的文件描述符的数量
           - rss - 最大驻留集大小 (单位KB)
           - stack - 最大栈的大小 (KB)
           - cpu - 最多CPU占用时间，单位为MIN分钟
           - nproc - 最大可以打开的进程数量
           - as - 地址空间限制 (KB)
           - maxlogins - 用户可以同时登录的最大数量
           - maxsyslogins - 系统最大允许的登录数量
           - priority - 运行用户进程的优先级
           - locks - 用户可以持有的文件锁的最大数量
           - sigpending - 最大挂起信号数
           - msgqueue - POSIX 消息队列使用的最大内存 (单位 bytes)
           - nice - 允许的最大优先级提高到值 [-20，19]
           - rtprio - 最大实时优先级
         - value： 就是为item设置的具体的数值。
      3. nofile 即为文件描述符最大数量
         - 配置：``tom hard nofile 10240``
         - 表示**tom用户**创建的**每个进程**的打开的最大的文件描述符数量不能超过硬限制**10240**
      4. type选项中hard和sort的差别
         - 限制达到soft只记录警告日志，不影响功能；日志文件一般在`/var/log/messages`
         - 限制达到hard会影响功能
   
2. 一个用户最多可以打开多少个文件描述符

   1. 一个用户最多可以打开多少个文件描述符 = 用户最大进程数 * 进程最大文件描述符数
   2. 用户最大进程数配置
      - `ulimit -u 1024` 修改当前shell用户最大进程数为1024
      - `/etc/security/limits.conf` 添加 `hard      nproc      131072`永久修改
      - 修改`/etc/security/limits.d/90-nproc.conf`文件 添加 `root       soft    nproc     131072`
      - `/etc/security/limits.d/`目录下的配置会覆盖`/etc/security/limits.conf`中的配置
      - `cat /proc/sys/kernel/pid_max` 设置或查看操作系统总的进程数量
   3. 即用户打开的最大进程数 < hard limit < pid_max。

3. 一个系统最多可以打开多少个文件描述符
   - `cat /proc/sys/fs/file-max` 系统总限制，一般不会达到，可以检查修改
4. 总结
   - 一个进程可以打开的文件描述符的数量小于hard limit，而hard limit的值要小于nr_open。但是实际能打开的文件描述符的最大数量还和系统资源有关。
   - 一个用户可以打开的文件描述符数量等于一个进程可以打开的文件描述符的数量* 一个用户最大可以打开的进程数量。
   - 一个系统可以打开的文件描述符数量即所有用户的所有进程打开的文件描述符总数量受file-max限制。

#### 2.2 poll

